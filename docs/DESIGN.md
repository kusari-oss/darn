# Darn/Darnit Design

Darn is a project that is intended to to implement security best practices through remediation based on findings generated by other tools. So for example if OpenSSF scorecard reported that there's an issue with MFA and your project is in Github it will run the gh cli to update the org to enable MFA.

## Principles

* Be stateless - This is not a tool like terraform.
* Don't double do the work of the security scanning tools - Assume that the reports are accurate and remediate based on it.
* CLI tool commands should be noun verb  - So `darn action run` as opposed to `darn run action`.

## Darn

Darn is intended to be a simple tool that just runs darn actions. Darn actions are defined by configs that include the following things:

* name: The name of the action
* type: The type of action being run, like a templated file action or cli command
  * There are also type specific fields. So for example for a CLI action it would include command and args.
* schema: This is a json schema for user defined parameters that can be plugged in to other fields as string substituation. For example part of a command line argument.

Eventually there should be a way to label these actions with metadata allowing for easy discovery of actions that are related to a particular security best practice or for similar filtering and organization use cases.

## Darnit

Darnit is a tool that will take in some metadata like a scorecard report or in-toto attestation and generate a remediation plan based on configuration that maps elements from the metadata to one or more Darn actions.

For example:

1. A report says that there's no valid security documentation for project
2. Darnit gets passed this report along with information on the project/repo and introspects the report based on configuration
3. Darnit configuration maps the proof of lack of security documentation from the report to a set of remediation darn actions that include:
   1. Clone down the repo (or run it against an existing local repo depending on how you're running this)
   2. Run the security documentation darn action in the local copy of the repo which will take in parameters about the project and plug them into the SECURITY.md file template
   3. Stage and commit the files
   4. Open a pull request.

This is a simple example, but it would do similar things if more things were found. So if there were multiple security findings it might generate a SECURITY.md, enable MFA on Github, enable a SLSA build, etc.